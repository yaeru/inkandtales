{"version":3,"sources":["webpack:///./node_modules/graphql/language/blockString.mjs","webpack:///./node_modules/graphql/language/kinds.mjs","webpack:///./node_modules/graphql/language/tokenKind.mjs","webpack:///./node_modules/graphql/language/source.mjs","webpack:///./node_modules/graphql/language/directiveLocation.mjs","webpack:///./node_modules/graphql/language/lexer.mjs","webpack:///./node_modules/graphql/language/parser.mjs","webpack:///./node_modules/graphql/language/visitor.mjs","webpack:///./node_modules/headful/dist/headful.js","webpack:///./node_modules/graphql/language/printer.mjs","webpack:///./node_modules/graphql/language/ast.mjs","webpack:///./node_modules/graphql/language/location.mjs","webpack:///./node_modules/graphql/language/printLocation.mjs","webpack:///./node_modules/graphql/polyfills/symbols.mjs"],"names":["dedentBlockStringValue","rawString","lines","split","commonIndent","getBlockStringIndentation","i","length","slice","startLine","isBlank","endLine","join","str","value","_commonIndent","isFirstLine","isEmptyLine","indent","charCodeAt","printBlockString","indentation","arguments","undefined","preferMultipleLines","isSingleLine","indexOf","hasLeadingSpace","hasTrailingQuote","hasTrailingSlash","printAsMultipleLines","result","replace","Kind","Object","freeze","NAME","DOCUMENT","OPERATION_DEFINITION","VARIABLE_DEFINITION","SELECTION_SET","FIELD","ARGUMENT","FRAGMENT_SPREAD","INLINE_FRAGMENT","FRAGMENT_DEFINITION","VARIABLE","INT","FLOAT","STRING","BOOLEAN","NULL","ENUM","LIST","OBJECT","OBJECT_FIELD","DIRECTIVE","NAMED_TYPE","LIST_TYPE","NON_NULL_TYPE","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","OBJECT_TYPE_DEFINITION","FIELD_DEFINITION","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","UNION_TYPE_DEFINITION","ENUM_TYPE_DEFINITION","ENUM_VALUE_DEFINITION","INPUT_OBJECT_TYPE_DEFINITION","DIRECTIVE_DEFINITION","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","TokenKind","SOF","EOF","BANG","DOLLAR","AMP","PAREN_L","PAREN_R","SPREAD","COLON","EQUALS","AT","BRACKET_L","BRACKET_R","BRACE_L","PIPE","BRACE_R","BLOCK_STRING","COMMENT","_defineProperties","target","props","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","Source","body","name","locationOffset","line","column","devAssert","concat","inspect","this","get","isSource","source","instanceOf","DirectiveLocation","QUERY","MUTATION","SUBSCRIPTION","SCHEMA","SCALAR","ARGUMENT_DEFINITION","INTERFACE","UNION","ENUM_VALUE","INPUT_OBJECT","INPUT_FIELD_DEFINITION","Lexer","startOfFileToken","lastToken","token","lineStart","_proto","advance","lookahead","kind","_token$next","next","readToken","isPunctuatorTokenKind","printCharCode","code","isNaN","JSON","stringify","String","fromCharCode","toString","toUpperCase","lexer","prev","bodyLength","pos","end","_line","_col","readComment","readBlockString","readString","readNumber","readName","syntaxError","unexpectedCharacterMessage","col","start","position","firstCode","isFloat","readDigits","isNameStart","chunkStart","charCode","uniCharCode","invalidSequence","rawValue","a","b","c","d","char2hex","parse","options","parser","parseDocument","parseValue","expectToken","parseValueLiteral","parseType","type","parseTypeReference","Parser","sourceObj","_lexer","_options","parseName","loc","definitions","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","peekDescription","unexpected","operation","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","parseVariableDefinition","variable","parseVariable","defaultValue","expectOptionalToken","selections","parseSelection","parseFragment","parseField","alias","nameOrAlias","parseArguments","isConst","item","parseConstArgument","parseArgument","hasTypeCondition","expectOptionalKeyword","parseFragmentName","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","parseList","parseObject","parseStringLiteral","block","_this","values","any","_this2","parseObjectField","fields","push","parseDirective","keywordToken","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","description","operationTypes","parseOperationTypeDefinition","interfaces","parseImplementsInterfaces","parseFieldsDefinition","_this$_options2","allowLegacySDLImplementsInterfaces","types","delimitedMany","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","args","parseArgumentDefs","parseInputValueDef","parseUnionMemberTypes","parseEnumValuesDefinition","parseEnumValueDefinition","parseInputFieldsDefinition","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","repeatable","locations","parseDirectiveLocations","parseDirectiveLocation","startToken","_this$_options4","noLocation","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","call","delimiterKind","QueryDocumentKeys","Name","Document","OperationDefinition","VariableDefinition","Variable","SelectionSet","Field","Argument","FragmentSpread","InlineFragment","FragmentDefinition","IntValue","FloatValue","StringValue","BooleanValue","NullValue","EnumValue","ListValue","ObjectValue","ObjectField","Directive","NamedType","ListType","NonNullType","SchemaDefinition","OperationTypeDefinition","ScalarTypeDefinition","ObjectTypeDefinition","FieldDefinition","InputValueDefinition","InterfaceTypeDefinition","UnionTypeDefinition","EnumTypeDefinition","EnumValueDefinition","InputObjectTypeDefinition","DirectiveDefinition","SchemaExtension","ScalarTypeExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","BREAK","visit","root","visitor","visitorKeys","stack","inArray","Array","isArray","keys","index","edits","node","parent","path","ancestors","newRoot","isLeaving","isEdited","pop","clone","_i2","_Object$keys2","k","editOffset","ii","editKey","editValue","splice","_visitorKeys$node$kin","Error","visitFn","getVisitFn","kindVisitor","kindSpecificVisitor","leave","enter","specificVisitor","specificKindVisitor","exports","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","done","err","TypeError","default","headful","conf","debug","propertySetters","html","obj","forEach","selector","setRootElementAttributes","head","setHeadElementAttributes","title","val","document","isRemoveValue","setMetaContent","keywords","image","lang","noProp","ogLocale","setOgLocaleIfValid","url","href","userConf","assign","prop","hasOwnProperty","propNameOrFunction","propName","attr","content","attributes","setElementAttributes","getElement","element","attrName","removeAttribute","setAttribute","querySelector","console","error","locale","match","_locale$split","_locale$split2","language","region","print","ast","printDocASTReducer","MAX_LINE_LENGTH","op","varDefs","wrap","_ref","_ref2","_ref3","prefix","argsLine","_ref4","_ref5","_ref6","_ref7","_ref8","_ref9","_ref10","isBlockString","_ref11","_ref12","_ref13","_ref14","_ref15","_ref16","_ref17","_ref18","_ref19","addDescription","_ref20","_ref21","_ref22","_ref23","_ref24","hasMultilineItems","_ref25","_ref26","_ref27","_ref28","_ref29","_ref30","_ref31","_ref32","_ref33","_ref34","_ref35","_ref36","_ref37","_ref38","cb","maybeArray","_maybeArray$filter$jo","separator","filter","x","array","maybeString","isMultiline","some","Location","endToken","toJSON","Token","_proto2","isNode","maybeNode","getLocation","lineRegexp","exec","printLocation","location","printSourceLocation","sourceLocation","firstLineColumnOffset","whitespace","lineIndex","lineOffset","lineNum","columnOffset","columnNum","locationStr","locationLine","subLineIndex","Math","floor","subLineColumnNum","subLines","printPrefixedLines","map","subLine","existingLines","padLen","max","apply","leftPad","len","asyncIterator","SYMBOL_TO_STRING_TAG","toStringTag"],"mappings":"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","file":"js/chunk-vendors~73914085.b153cccc.js","sourcesContent":["/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(rawString);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  var startLine = 0;\n\n  while (startLine < lines.length && isBlank(lines[startLine])) {\n    ++startLine;\n  }\n\n  var endLine = lines.length;\n\n  while (endLine > startLine && isBlank(lines[endLine - 1])) {\n    --endLine;\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.slice(startLine, endLine).join('\\n');\n}\n\nfunction isBlank(str) {\n  for (var i = 0; i < str.length; ++i) {\n    if (str[i] !== ' ' && str[i] !== '\\t') {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * @internal\n */\n\n\nexport function getBlockStringIndentation(value) {\n  var _commonIndent;\n\n  var isFirstLine = true;\n  var isEmptyLine = true;\n  var indent = 0;\n  var commonIndent = null;\n\n  for (var i = 0; i < value.length; ++i) {\n    switch (value.charCodeAt(i)) {\n      case 13:\n        //  \\r\n        if (value.charCodeAt(i + 1) === 10) {\n          ++i; // skip \\r\\n as one symbol\n        }\n\n      // falls through\n\n      case 10:\n        //  \\n\n        isFirstLine = false;\n        isEmptyLine = true;\n        indent = 0;\n        break;\n\n      case 9: //   \\t\n\n      case 32:\n        //  <space>\n        ++indent;\n        break;\n\n      default:\n        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent < commonIndent)) {\n          commonIndent = indent;\n        }\n\n        isEmptyLine = false;\n    }\n  }\n\n  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var hasTrailingSlash = value[value.length - 1] === '\\\\';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","/**\n * The set of allowed kind values for AST nodes.\n */\nexport var Kind = Object.freeze({\n  // Name\n  NAME: 'Name',\n  // Document\n  DOCUMENT: 'Document',\n  OPERATION_DEFINITION: 'OperationDefinition',\n  VARIABLE_DEFINITION: 'VariableDefinition',\n  SELECTION_SET: 'SelectionSet',\n  FIELD: 'Field',\n  ARGUMENT: 'Argument',\n  // Fragments\n  FRAGMENT_SPREAD: 'FragmentSpread',\n  INLINE_FRAGMENT: 'InlineFragment',\n  FRAGMENT_DEFINITION: 'FragmentDefinition',\n  // Values\n  VARIABLE: 'Variable',\n  INT: 'IntValue',\n  FLOAT: 'FloatValue',\n  STRING: 'StringValue',\n  BOOLEAN: 'BooleanValue',\n  NULL: 'NullValue',\n  ENUM: 'EnumValue',\n  LIST: 'ListValue',\n  OBJECT: 'ObjectValue',\n  OBJECT_FIELD: 'ObjectField',\n  // Directives\n  DIRECTIVE: 'Directive',\n  // Types\n  NAMED_TYPE: 'NamedType',\n  LIST_TYPE: 'ListType',\n  NON_NULL_TYPE: 'NonNullType',\n  // Type System Definitions\n  SCHEMA_DEFINITION: 'SchemaDefinition',\n  OPERATION_TYPE_DEFINITION: 'OperationTypeDefinition',\n  // Type Definitions\n  SCALAR_TYPE_DEFINITION: 'ScalarTypeDefinition',\n  OBJECT_TYPE_DEFINITION: 'ObjectTypeDefinition',\n  FIELD_DEFINITION: 'FieldDefinition',\n  INPUT_VALUE_DEFINITION: 'InputValueDefinition',\n  INTERFACE_TYPE_DEFINITION: 'InterfaceTypeDefinition',\n  UNION_TYPE_DEFINITION: 'UnionTypeDefinition',\n  ENUM_TYPE_DEFINITION: 'EnumTypeDefinition',\n  ENUM_VALUE_DEFINITION: 'EnumValueDefinition',\n  INPUT_OBJECT_TYPE_DEFINITION: 'InputObjectTypeDefinition',\n  // Directive Definitions\n  DIRECTIVE_DEFINITION: 'DirectiveDefinition',\n  // Type System Extensions\n  SCHEMA_EXTENSION: 'SchemaExtension',\n  // Type Extensions\n  SCALAR_TYPE_EXTENSION: 'ScalarTypeExtension',\n  OBJECT_TYPE_EXTENSION: 'ObjectTypeExtension',\n  INTERFACE_TYPE_EXTENSION: 'InterfaceTypeExtension',\n  UNION_TYPE_EXTENSION: 'UnionTypeExtension',\n  ENUM_TYPE_EXTENSION: 'EnumTypeExtension',\n  INPUT_OBJECT_TYPE_EXTENSION: 'InputObjectTypeExtension'\n});\n/**\n * The enum type representing the possible kind values of AST nodes.\n */\n","/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport var TokenKind = Object.freeze({\n  SOF: '<SOF>',\n  EOF: '<EOF>',\n  BANG: '!',\n  DOLLAR: '$',\n  AMP: '&',\n  PAREN_L: '(',\n  PAREN_R: ')',\n  SPREAD: '...',\n  COLON: ':',\n  EQUALS: '=',\n  AT: '@',\n  BRACKET_L: '[',\n  BRACKET_R: ']',\n  BRACE_L: '{',\n  PIPE: '|',\n  BRACE_R: '}',\n  NAME: 'Name',\n  INT: 'Int',\n  FLOAT: 'Float',\n  STRING: 'String',\n  BLOCK_STRING: 'BlockString',\n  COMMENT: 'Comment'\n});\n/**\n * The enum type representing the token kinds values.\n */\n","function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { SYMBOL_TO_STRING_TAG } from \"../polyfills/symbols.mjs\";\nimport inspect from \"../jsutils/inspect.mjs\";\nimport devAssert from \"../jsutils/devAssert.mjs\";\nimport instanceOf from \"../jsutils/instanceOf.mjs\";\n\n/**\n * A representation of source input to GraphQL. The `name` and `locationOffset` parameters are\n * optional, but they are useful for clients who store GraphQL documents in source files.\n * For example, if the GraphQL input starts at line 40 in a file named `Foo.graphql`, it might\n * be useful for `name` to be `\"Foo.graphql\"` and location to be `{ line: 40, column: 1 }`.\n * The `line` and `column` properties in `locationOffset` are 1-indexed.\n */\nexport var Source = /*#__PURE__*/function () {\n  function Source(body) {\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GraphQL request';\n    var locationOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      line: 1,\n      column: 1\n    };\n    typeof body === 'string' || devAssert(0, \"Body must be a string. Received: \".concat(inspect(body), \".\"));\n    this.body = body;\n    this.name = name;\n    this.locationOffset = locationOffset;\n    this.locationOffset.line > 0 || devAssert(0, 'line in locationOffset is 1-indexed and must be positive.');\n    this.locationOffset.column > 0 || devAssert(0, 'column in locationOffset is 1-indexed and must be positive.');\n  } // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet\n\n\n  _createClass(Source, [{\n    key: SYMBOL_TO_STRING_TAG,\n    get: function get() {\n      return 'Source';\n    }\n  }]);\n\n  return Source;\n}();\n/**\n * Test if the given value is a Source object.\n *\n * @internal\n */\n\n// eslint-disable-next-line no-redeclare\nexport function isSource(source) {\n  return instanceOf(source, Source);\n}\n","/**\n * The set of allowed directive location values.\n */\nexport var DirectiveLocation = Object.freeze({\n  // Request Definitions\n  QUERY: 'QUERY',\n  MUTATION: 'MUTATION',\n  SUBSCRIPTION: 'SUBSCRIPTION',\n  FIELD: 'FIELD',\n  FRAGMENT_DEFINITION: 'FRAGMENT_DEFINITION',\n  FRAGMENT_SPREAD: 'FRAGMENT_SPREAD',\n  INLINE_FRAGMENT: 'INLINE_FRAGMENT',\n  VARIABLE_DEFINITION: 'VARIABLE_DEFINITION',\n  // Type System Definitions\n  SCHEMA: 'SCHEMA',\n  SCALAR: 'SCALAR',\n  OBJECT: 'OBJECT',\n  FIELD_DEFINITION: 'FIELD_DEFINITION',\n  ARGUMENT_DEFINITION: 'ARGUMENT_DEFINITION',\n  INTERFACE: 'INTERFACE',\n  UNION: 'UNION',\n  ENUM: 'ENUM',\n  ENUM_VALUE: 'ENUM_VALUE',\n  INPUT_OBJECT: 'INPUT_OBJECT',\n  INPUT_FIELD_DEFINITION: 'INPUT_FIELD_DEFINITION'\n});\n/**\n * The enum type representing the directive location values.\n */\n","import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Token } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { dedentBlockStringValue } from \"./blockString.mjs\";\n/**\n * Given a Source object, creates a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\n\nexport var Lexer = /*#__PURE__*/function () {\n  /**\n   * The previously focused non-ignored token.\n   */\n\n  /**\n   * The currently focused non-ignored token.\n   */\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  function Lexer(source) {\n    var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);\n    this.source = source;\n    this.lastToken = startOfFileToken;\n    this.token = startOfFileToken;\n    this.line = 1;\n    this.lineStart = 0;\n  }\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n\n\n  var _proto = Lexer.prototype;\n\n  _proto.advance = function advance() {\n    this.lastToken = this.token;\n    var token = this.token = this.lookahead();\n    return token;\n  }\n  /**\n   * Looks ahead and returns the next non-ignored token, but does not change\n   * the state of Lexer.\n   */\n  ;\n\n  _proto.lookahead = function lookahead() {\n    var token = this.token;\n\n    if (token.kind !== TokenKind.EOF) {\n      do {\n        var _token$next;\n\n        // Note: next is only mutable during parsing, so we cast to allow this.\n        token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);\n      } while (token.kind === TokenKind.COMMENT);\n    }\n\n    return token;\n  };\n\n  return Lexer;\n}();\n/**\n * @internal\n */\n\nexport function isPunctuatorTokenKind(kind) {\n  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;\n}\n\nfunction printCharCode(code) {\n  return (// NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? TokenKind.EOF : // Trust JSON for ASCII.\n    code < 0x007f ? JSON.stringify(String.fromCharCode(code)) : // Otherwise print the escaped form.\n    \"\\\"\\\\u\".concat(('00' + code.toString(16).toUpperCase()).slice(-4), \"\\\"\")\n  );\n}\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace until it finds the next lexable token, then lexes\n * punctuators immediately or calls the appropriate helper function for more\n * complicated tokens.\n */\n\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n  var pos = prev.end;\n\n  while (pos < bodyLength) {\n    var code = body.charCodeAt(pos);\n    var _line = lexer.line;\n\n    var _col = 1 + pos - lexer.lineStart; // SourceCharacter\n\n\n    switch (code) {\n      case 0xfeff: // <BOM>\n\n      case 9: //   \\t\n\n      case 32: //  <space>\n\n      case 44:\n        //  ,\n        ++pos;\n        continue;\n\n      case 10:\n        //  \\n\n        ++pos;\n        ++lexer.line;\n        lexer.lineStart = pos;\n        continue;\n\n      case 13:\n        //  \\r\n        if (body.charCodeAt(pos + 1) === 10) {\n          pos += 2;\n        } else {\n          ++pos;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = pos;\n        continue;\n\n      case 33:\n        //  !\n        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);\n\n      case 35:\n        //  #\n        return readComment(source, pos, _line, _col, prev);\n\n      case 36:\n        //  $\n        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);\n\n      case 38:\n        //  &\n        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);\n\n      case 40:\n        //  (\n        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);\n\n      case 41:\n        //  )\n        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);\n\n      case 46:\n        //  .\n        if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {\n          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);\n        }\n\n        break;\n\n      case 58:\n        //  :\n        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);\n\n      case 61:\n        //  =\n        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);\n\n      case 64:\n        //  @\n        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);\n\n      case 91:\n        //  [\n        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);\n\n      case 93:\n        //  ]\n        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);\n\n      case 123:\n        // {\n        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);\n\n      case 124:\n        // |\n        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);\n\n      case 125:\n        // }\n        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);\n\n      case 34:\n        //  \"\n        if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {\n          return readBlockString(source, pos, _line, _col, prev, lexer);\n        }\n\n        return readString(source, pos, _line, _col, prev);\n\n      case 45: //  -\n\n      case 48: //  0\n\n      case 49: //  1\n\n      case 50: //  2\n\n      case 51: //  3\n\n      case 52: //  4\n\n      case 53: //  5\n\n      case 54: //  6\n\n      case 55: //  7\n\n      case 56: //  8\n\n      case 57:\n        //  9\n        return readNumber(source, pos, code, _line, _col, prev);\n\n      case 65: //  A\n\n      case 66: //  B\n\n      case 67: //  C\n\n      case 68: //  D\n\n      case 69: //  E\n\n      case 70: //  F\n\n      case 71: //  G\n\n      case 72: //  H\n\n      case 73: //  I\n\n      case 74: //  J\n\n      case 75: //  K\n\n      case 76: //  L\n\n      case 77: //  M\n\n      case 78: //  N\n\n      case 79: //  O\n\n      case 80: //  P\n\n      case 81: //  Q\n\n      case 82: //  R\n\n      case 83: //  S\n\n      case 84: //  T\n\n      case 85: //  U\n\n      case 86: //  V\n\n      case 87: //  W\n\n      case 88: //  X\n\n      case 89: //  Y\n\n      case 90: //  Z\n\n      case 95: //  _\n\n      case 97: //  a\n\n      case 98: //  b\n\n      case 99: //  c\n\n      case 100: // d\n\n      case 101: // e\n\n      case 102: // f\n\n      case 103: // g\n\n      case 104: // h\n\n      case 105: // i\n\n      case 106: // j\n\n      case 107: // k\n\n      case 108: // l\n\n      case 109: // m\n\n      case 110: // n\n\n      case 111: // o\n\n      case 112: // p\n\n      case 113: // q\n\n      case 114: // r\n\n      case 115: // s\n\n      case 116: // t\n\n      case 117: // u\n\n      case 118: // v\n\n      case 119: // w\n\n      case 120: // x\n\n      case 121: // y\n\n      case 122:\n        // z\n        return readName(source, pos, _line, _col, prev);\n    }\n\n    throw syntaxError(source, pos, unexpectedCharacterMessage(code));\n  }\n\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n}\n/**\n * Report a message that an unexpected character was encountered.\n */\n\n\nfunction unexpectedCharacterMessage(code) {\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n    return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n  }\n\n  if (code === 39) {\n    // '\n    return 'Unexpected single quote character (\\'), did you mean to use a double quote (\")?';\n  }\n\n  return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n}\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\n\n\nfunction readComment(source, start, line, col, prev) {\n  var body = source.body;\n  var code;\n  var position = start;\n\n  do {\n    code = body.charCodeAt(++position);\n  } while (!isNaN(code) && ( // SourceCharacter but not LineTerminator\n  code > 0x001f || code === 0x0009));\n\n  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n}\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\n\n\nfunction readNumber(source, start, firstCode, line, col, prev) {\n  var body = source.body;\n  var code = firstCode;\n  var position = start;\n  var isFloat = false;\n\n  if (code === 45) {\n    // -\n    code = body.charCodeAt(++position);\n  }\n\n  if (code === 48) {\n    // 0\n    code = body.charCodeAt(++position);\n\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 46) {\n    // .\n    isFloat = true;\n    code = body.charCodeAt(++position);\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  }\n\n  if (code === 69 || code === 101) {\n    // E e\n    isFloat = true;\n    code = body.charCodeAt(++position);\n\n    if (code === 43 || code === 45) {\n      // + -\n      code = body.charCodeAt(++position);\n    }\n\n    position = readDigits(source, position, code);\n    code = body.charCodeAt(position);\n  } // Numbers cannot be followed by . or NameStart\n\n\n  if (code === 46 || isNameStart(code)) {\n    throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n  }\n\n  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n}\n/**\n * Returns the new position in the source after reading digits.\n */\n\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    // 0 - 9\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\n\n\nfunction readString(source, start, line, col, prev) {\n  var body = source.body;\n  var position = start + 1;\n  var chunkStart = position;\n  var code = 0;\n  var value = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && // not LineTerminator\n  code !== 0x000a && code !== 0x000d) {\n    // Closing Quote (\")\n    if (code === 34) {\n      value += body.slice(chunkStart, position);\n      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    ++position;\n\n    if (code === 92) {\n      // \\\n      value += body.slice(chunkStart, position - 1);\n      code = body.charCodeAt(position);\n\n      switch (code) {\n        case 34:\n          value += '\"';\n          break;\n\n        case 47:\n          value += '/';\n          break;\n\n        case 92:\n          value += '\\\\';\n          break;\n\n        case 98:\n          value += '\\b';\n          break;\n\n        case 102:\n          value += '\\f';\n          break;\n\n        case 110:\n          value += '\\n';\n          break;\n\n        case 114:\n          value += '\\r';\n          break;\n\n        case 116:\n          value += '\\t';\n          break;\n\n        case 117:\n          {\n            // uXXXX\n            var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));\n\n            if (charCode < 0) {\n              var invalidSequence = body.slice(position + 1, position + 5);\n              throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n            }\n\n            value += String.fromCharCode(charCode);\n            position += 4;\n            break;\n          }\n\n        default:\n          throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n      }\n\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Reads a block string token from the source file.\n *\n * \"\"\"(\"?\"?(\\\\\"\"\"|\\\\(?!=\"\"\")|[^\"\\\\]))*\"\"\"\n */\n\n\nfunction readBlockString(source, start, line, col, prev, lexer) {\n  var body = source.body;\n  var position = start + 3;\n  var chunkStart = position;\n  var code = 0;\n  var rawValue = '';\n\n  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n    // Closing Triple-Quote (\"\"\")\n    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {\n      rawValue += body.slice(chunkStart, position);\n      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n    } // SourceCharacter\n\n\n    if (code < 0x0020 && code !== 0x0009 && code !== 0x000a && code !== 0x000d) {\n      throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n    }\n\n    if (code === 10) {\n      // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) {\n      // carriage return\n      if (body.charCodeAt(position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if ( // Escape Triple-Quote (\\\"\"\")\n    code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {\n      rawValue += body.slice(chunkStart, position) + '\"\"\"';\n      position += 4;\n      chunkStart = position;\n    } else {\n      ++position;\n    }\n  }\n\n  throw syntaxError(source, position, 'Unterminated string.');\n}\n/**\n * Converts four hexadecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\n\n\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\n\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 // 0-9\n  : a >= 65 && a <= 70 ? a - 55 // A-F\n  : a >= 97 && a <= 102 ? a - 87 // a-f\n  : -1;\n}\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\n\n\nfunction readName(source, start, line, col, prev) {\n  var body = source.body;\n  var bodyLength = body.length;\n  var position = start + 1;\n  var code = 0;\n\n  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || // _\n  code >= 48 && code <= 57 || // 0-9\n  code >= 65 && code <= 90 || // A-Z\n  code >= 97 && code <= 122) // a-z\n  ) {\n    ++position;\n  }\n\n  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n} // _ A-Z a-z\n\n\nfunction isNameStart(code) {\n  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;\n}\n","import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Location } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { Source, isSource } from \"./source.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\n/**\n * Configuration options to control parser behavior\n */\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\n * that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: valueFromAST().\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\n * that type.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Types directly and\n * in isolation of complete GraphQL documents.\n *\n * Consider providing the results to the utility function: typeFromAST().\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\n * This class is exported only to assist people in implementing their own parsers\n * without duplicating too much code and should be used only as last resort for cases\n * such as experimental syntax or if certain features could not be contributed upstream.\n *\n * It is still part of the internal API and is versioned, so any changes to it are never\n * considered breaking changes. If you still need to support multiple versions of the\n * library, please use the `versionInfo` variable for version detection.\n *\n * @internal\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\n   * Converts a name lex token into a name parse node.\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\n   * Document : Definition+\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Definition :\n   *   - ExecutableDefinition\n   *   - TypeSystemDefinition\n   *   - TypeSystemExtension\n   *\n   * ExecutableDefinition :\n   *   - OperationDefinition\n   *   - FragmentDefinition\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\n   * OperationDefinition :\n   *  - SelectionSet\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationType : one of query mutation subscription\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\n   * VariableDefinitions : ( VariableDefinition+ )\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Variable : $ Name\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * SelectionSet : { Selection+ }\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Selection :\n   *   - Field\n   *   - FragmentSpread\n   *   - InlineFragment\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\n   *\n   * Alias : Name :\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * Arguments[Const] : ( Argument[?Const]+ )\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\n   * Argument[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\n   *\n   * FragmentSpread : ... FragmentName Directives?\n   *\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentDefinition :\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n   *\n   * TypeCondition : NamedType\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * FragmentName : Name but not `on`\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\n   * Value[Const] :\n   *   - [~Const] Variable\n   *   - IntValue\n   *   - FloatValue\n   *   - StringValue\n   *   - BooleanValue\n   *   - NullValue\n   *   - EnumValue\n   *   - ListValue[?Const]\n   *   - ObjectValue[?Const]\n   *\n   * BooleanValue : one of `true` `false`\n   *\n   * NullValue : `null`\n   *\n   * EnumValue : Name but not `true`, `false` or `null`\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\n   * ListValue[Const] :\n   *   - [ ]\n   *   - [ Value[?Const]+ ]\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectValue[Const] :\n   *   - { }\n   *   - { ObjectField[?Const]+ }\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectField[Const] : Name : Value[?Const]\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\n   * Directives[Const] : Directive[?Const]+\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\n   * Directive[Const] : @ Name Arguments[?Const]?\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\n   * Type :\n   *   - NamedType\n   *   - ListType\n   *   - NonNullType\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\n   * NamedType : Name\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\n   * TypeSystemDefinition :\n   *   - SchemaDefinition\n   *   - TypeDefinition\n   *   - DirectiveDefinition\n   *\n   * TypeDefinition :\n   *   - ScalarTypeDefinition\n   *   - ObjectTypeDefinition\n   *   - InterfaceTypeDefinition\n   *   - UnionTypeDefinition\n   *   - EnumTypeDefinition\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\n   * Description : StringValue\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * OperationTypeDefinition : OperationType : NamedType\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeDefinition :\n   *   Description?\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ImplementsInterfaces :\n   *   - implements `&`? NamedType\n   *   - ImplementsInterfaces & NamedType\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var _this$_options2;\n\n    if (!this.expectOptionalKeyword('implements')) {\n      return [];\n    }\n\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {\n      var types = []; // Optional leading ampersand\n\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));\n\n      return types;\n    }\n\n    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);\n  }\n  /**\n   * FieldsDefinition : { FieldDefinition+ }\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3;\n\n    // Legacy support for the SDL?\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * FieldDefinition :\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ArgumentsDefinition : ( InputValueDefinition+ )\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\n   * InputValueDefinition :\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeDefinition :\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeDefinition :\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionMemberTypes :\n   *   - = `|`? NamedType\n   *   - UnionMemberTypes | NamedType\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\n   * EnumTypeDefinition :\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumValuesDefinition : { EnumValueDefinition+ }\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\n   *\n   * EnumValue : Name\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeDefinition :\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputFieldsDefinition : { InputValueDefinition+ }\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\n   * TypeSystemExtension :\n   *   - SchemaExtension\n   *   - TypeExtension\n   *\n   * TypeExtension :\n   *   - ScalarTypeExtension\n   *   - ObjectTypeExtension\n   *   - InterfaceTypeExtension\n   *   - UnionTypeExtension\n   *   - EnumTypeExtension\n   *   - InputObjectTypeDefinition\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\n   * SchemaExtension :\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\n   *  - extend schema Directives[Const]\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ScalarTypeExtension :\n   *   - extend scalar Name Directives[Const]\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * ObjectTypeExtension :\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\n   *  - extend type Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InterfaceTypeExtension :\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\n   *  - extend interface Name ImplementsInterfaces\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * UnionTypeExtension :\n   *   - extend union Name Directives[Const]? UnionMemberTypes\n   *   - extend union Name Directives[Const]\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * EnumTypeExtension :\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\n   *   - extend enum Name Directives[Const]\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * InputObjectTypeExtension :\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\n   *   - extend input Name Directives[Const]\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveDefinition :\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\n   * DirectiveLocations :\n   *   - `|`? DirectiveLocation\n   *   - DirectiveLocations | DirectiveLocation\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\n   * DirectiveLocation :\n   *   - ExecutableDirectiveLocation\n   *   - TypeSystemDirectiveLocation\n   *\n   * ExecutableDirectiveLocation : one of\n   *   `QUERY`\n   *   `MUTATION`\n   *   `SUBSCRIPTION`\n   *   `FIELD`\n   *   `FRAGMENT_DEFINITION`\n   *   `FRAGMENT_SPREAD`\n   *   `INLINE_FRAGMENT`\n   *\n   * TypeSystemDirectiveLocation : one of\n   *   `SCHEMA`\n   *   `SCALAR`\n   *   `OBJECT`\n   *   `FIELD_DEFINITION`\n   *   `ARGUMENT_DEFINITION`\n   *   `INTERFACE`\n   *   `UNION`\n   *   `ENUM`\n   *   `ENUM_VALUE`\n   *   `INPUT_OBJECT`\n   *   `INPUT_FIELD_DEFINITION`\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\n   * Returns a location object, used to identify the place in the source that created a given parsed object.\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\n   * Determines if the next token is of a given kind\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * If the next token is of the given kind, return that token after advancing the lexer.\n   * Otherwise, do not change the parser state and return undefined.\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\n   * If the next token is a given keyword, advance the lexer.\n   * Otherwise, do not change the parser state and throw an error.\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\n   * Otherwise, do not change the parser state and return \"false\".\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Helper function for creating an error when an unexpected lexed token is encountered.\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns a list of parse nodes, determined by the parseFn.\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\n   * Advances the parser to the next lex token after the closing token.\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\n   * Advances the parser to the next lex token after last item in the list.\n   */\n  ;\n\n  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\n * A helper function to describe a token as a string for debugging.\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\n * A helper function to describe a token kind as a string for debugging.\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}\n","import inspect from \"../jsutils/inspect.mjs\";\nimport { isNode } from \"./ast.mjs\";\n/**\n * A visitor is provided to visit, it contains the collection of\n * relevant functions to be called during the visitor's traversal.\n */\n\nexport var QueryDocumentKeys = {\n  Name: [],\n  Document: ['definitions'],\n  OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],\n  VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],\n  Variable: ['name'],\n  SelectionSet: ['selections'],\n  Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],\n  Argument: ['name', 'value'],\n  FragmentSpread: ['name', 'directives'],\n  InlineFragment: ['typeCondition', 'directives', 'selectionSet'],\n  FragmentDefinition: ['name', // Note: fragment variable definitions are experimental and may be changed\n  // or removed in the future.\n  'variableDefinitions', 'typeCondition', 'directives', 'selectionSet'],\n  IntValue: [],\n  FloatValue: [],\n  StringValue: [],\n  BooleanValue: [],\n  NullValue: [],\n  EnumValue: [],\n  ListValue: ['values'],\n  ObjectValue: ['fields'],\n  ObjectField: ['name', 'value'],\n  Directive: ['name', 'arguments'],\n  NamedType: ['name'],\n  ListType: ['type'],\n  NonNullType: ['type'],\n  SchemaDefinition: ['description', 'directives', 'operationTypes'],\n  OperationTypeDefinition: ['type'],\n  ScalarTypeDefinition: ['description', 'name', 'directives'],\n  ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],\n  InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],\n  InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],\n  UnionTypeDefinition: ['description', 'name', 'directives', 'types'],\n  EnumTypeDefinition: ['description', 'name', 'directives', 'values'],\n  EnumValueDefinition: ['description', 'name', 'directives'],\n  InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],\n  DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],\n  SchemaExtension: ['directives', 'operationTypes'],\n  ScalarTypeExtension: ['name', 'directives'],\n  ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],\n  UnionTypeExtension: ['name', 'directives', 'types'],\n  EnumTypeExtension: ['name', 'directives', 'values'],\n  InputObjectTypeExtension: ['name', 'directives', 'fields']\n};\nexport var BREAK = Object.freeze({});\n/**\n * visit() will walk through an AST using a depth-first traversal, calling\n * the visitor's enter function at each node in the traversal, and calling the\n * leave function after visiting that node and all of its child nodes.\n *\n * By returning different values from the enter and leave functions, the\n * behavior of the visitor can be altered, including skipping over a sub-tree of\n * the AST (by returning false), editing the AST by returning a value or null\n * to remove the value, or to stop the whole traversal by returning BREAK.\n *\n * When using visit() to edit an AST, the original AST will not be modified, and\n * a new version of the AST with the changes applied will be returned from the\n * visit function.\n *\n *     const editedAST = visit(ast, {\n *       enter(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: skip visiting this node\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       },\n *       leave(node, key, parent, path, ancestors) {\n *         // @return\n *         //   undefined: no action\n *         //   false: no action\n *         //   visitor.BREAK: stop visiting altogether\n *         //   null: delete this node\n *         //   any value: replace this node with the returned value\n *       }\n *     });\n *\n * Alternatively to providing enter() and leave() functions, a visitor can\n * instead provide functions named the same as the kinds of AST nodes, or\n * enter/leave visitors at a named key, leading to four permutations of the\n * visitor API:\n *\n * 1) Named visitors triggered when entering a node of a specific kind.\n *\n *     visit(ast, {\n *       Kind(node) {\n *         // enter the \"Kind\" node\n *       }\n *     })\n *\n * 2) Named visitors that trigger upon entering and leaving a node of\n *    a specific kind.\n *\n *     visit(ast, {\n *       Kind: {\n *         enter(node) {\n *           // enter the \"Kind\" node\n *         }\n *         leave(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n *\n * 3) Generic visitors that trigger upon entering and leaving any node.\n *\n *     visit(ast, {\n *       enter(node) {\n *         // enter any node\n *       },\n *       leave(node) {\n *         // leave any node\n *       }\n *     })\n *\n * 4) Parallel visitors for entering and leaving nodes of a specific kind.\n *\n *     visit(ast, {\n *       enter: {\n *         Kind(node) {\n *           // enter the \"Kind\" node\n *         }\n *       },\n *       leave: {\n *         Kind(node) {\n *           // leave the \"Kind\" node\n *         }\n *       }\n *     })\n */\n\nexport function visit(root, visitor) {\n  var visitorKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : QueryDocumentKeys;\n\n  /* eslint-disable no-undef-init */\n  var stack = undefined;\n  var inArray = Array.isArray(root);\n  var keys = [root];\n  var index = -1;\n  var edits = [];\n  var node = undefined;\n  var key = undefined;\n  var parent = undefined;\n  var path = [];\n  var ancestors = [];\n  var newRoot = root;\n  /* eslint-enable no-undef-init */\n\n  do {\n    index++;\n    var isLeaving = index === keys.length;\n    var isEdited = isLeaving && edits.length !== 0;\n\n    if (isLeaving) {\n      key = ancestors.length === 0 ? undefined : path[path.length - 1];\n      node = parent;\n      parent = ancestors.pop();\n\n      if (isEdited) {\n        if (inArray) {\n          node = node.slice();\n        } else {\n          var clone = {};\n\n          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {\n            var k = _Object$keys2[_i2];\n            clone[k] = node[k];\n          }\n\n          node = clone;\n        }\n\n        var editOffset = 0;\n\n        for (var ii = 0; ii < edits.length; ii++) {\n          var editKey = edits[ii][0];\n          var editValue = edits[ii][1];\n\n          if (inArray) {\n            editKey -= editOffset;\n          }\n\n          if (inArray && editValue === null) {\n            node.splice(editKey, 1);\n            editOffset++;\n          } else {\n            node[editKey] = editValue;\n          }\n        }\n      }\n\n      index = stack.index;\n      keys = stack.keys;\n      edits = stack.edits;\n      inArray = stack.inArray;\n      stack = stack.prev;\n    } else {\n      key = parent ? inArray ? index : keys[index] : undefined;\n      node = parent ? parent[key] : newRoot;\n\n      if (node === null || node === undefined) {\n        continue;\n      }\n\n      if (parent) {\n        path.push(key);\n      }\n    }\n\n    var result = void 0;\n\n    if (!Array.isArray(node)) {\n      if (!isNode(node)) {\n        throw new Error(\"Invalid AST Node: \".concat(inspect(node), \".\"));\n      }\n\n      var visitFn = getVisitFn(visitor, node.kind, isLeaving);\n\n      if (visitFn) {\n        result = visitFn.call(visitor, node, key, parent, path, ancestors);\n\n        if (result === BREAK) {\n          break;\n        }\n\n        if (result === false) {\n          if (!isLeaving) {\n            path.pop();\n            continue;\n          }\n        } else if (result !== undefined) {\n          edits.push([key, result]);\n\n          if (!isLeaving) {\n            if (isNode(result)) {\n              node = result;\n            } else {\n              path.pop();\n              continue;\n            }\n          }\n        }\n      }\n    }\n\n    if (result === undefined && isEdited) {\n      edits.push([key, node]);\n    }\n\n    if (isLeaving) {\n      path.pop();\n    } else {\n      var _visitorKeys$node$kin;\n\n      stack = {\n        inArray: inArray,\n        index: index,\n        keys: keys,\n        edits: edits,\n        prev: stack\n      };\n      inArray = Array.isArray(node);\n      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];\n      index = -1;\n      edits = [];\n\n      if (parent) {\n        ancestors.push(parent);\n      }\n\n      parent = node;\n    }\n  } while (stack !== undefined);\n\n  if (edits.length !== 0) {\n    newRoot = edits[edits.length - 1][1];\n  }\n\n  return newRoot;\n}\n/**\n * Creates a new visitor instance which delegates to many visitors to run in\n * parallel. Each visitor will be visited for each node before moving on.\n *\n * If a prior visitor edits a node, no following visitors will see that node.\n */\n\nexport function visitInParallel(visitors) {\n  var skipping = new Array(visitors.length);\n  return {\n    enter: function enter(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (skipping[i] == null) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          false);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === false) {\n              skipping[i] = node;\n            } else if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined) {\n              return result;\n            }\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      for (var i = 0; i < visitors.length; i++) {\n        if (skipping[i] == null) {\n          var fn = getVisitFn(visitors[i], node.kind,\n          /* isLeaving */\n          true);\n\n          if (fn) {\n            var result = fn.apply(visitors[i], arguments);\n\n            if (result === BREAK) {\n              skipping[i] = BREAK;\n            } else if (result !== undefined && result !== false) {\n              return result;\n            }\n          }\n        } else if (skipping[i] === node) {\n          skipping[i] = null;\n        }\n      }\n    }\n  };\n}\n/**\n * Given a visitor instance, if it is leaving or not, and a node kind, return\n * the function the visitor runtime should call.\n */\n\nexport function getVisitFn(visitor, kind, isLeaving) {\n  var kindVisitor = visitor[kind];\n\n  if (kindVisitor) {\n    if (!isLeaving && typeof kindVisitor === 'function') {\n      // { Kind() {} }\n      return kindVisitor;\n    }\n\n    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;\n\n    if (typeof kindSpecificVisitor === 'function') {\n      // { Kind: { enter() {}, leave() {} } }\n      return kindSpecificVisitor;\n    }\n  } else {\n    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;\n\n    if (specificVisitor) {\n      if (typeof specificVisitor === 'function') {\n        // { enter() {}, leave() {} }\n        return specificVisitor;\n      }\n\n      var specificKindVisitor = specificVisitor[kind];\n\n      if (typeof specificKindVisitor === 'function') {\n        // { enter: { Kind() {} }, leave: { Kind() {} } }\n        return specificKindVisitor;\n      }\n    }\n  }\n}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.default = headful;\n\n\nvar conf = {\n    debug: false\n};\n\nvar propertySetters = {\n    html: function html(obj) {\n        obj && Object.keys(obj).forEach(function (selector) {\n            return setRootElementAttributes(selector, obj[selector]);\n        });\n    },\n    head: function head(obj) {\n        obj && Object.keys(obj).forEach(function (selector) {\n            return setHeadElementAttributes(selector, obj[selector]);\n        });\n    },\n    title: function title(val) {\n        document.title = isRemoveValue(val) ? '' : val;\n        setMetaContent('itemprop=\"name\"', val);\n        setMetaContent('property=\"og:title\"', val);\n        setMetaContent('name=\"twitter:title\"', val);\n    },\n    description: function description(val) {\n        setMetaContent('name=\"description\"', val);\n        setMetaContent('itemprop=\"description\"', val);\n        setMetaContent('property=\"og:description\"', val);\n        setMetaContent('name=\"twitter:description\"', val);\n    },\n    keywords: function keywords(val) {\n        setMetaContent('name=\"keywords\"', Array.isArray(val) ? val.join(', ') : val);\n    },\n    image: function image(val) {\n        setMetaContent('itemprop=\"image\"', val);\n        setMetaContent('property=\"og:image\"', val);\n        setMetaContent('name=\"twitter:image\"', val);\n    },\n    lang: function lang(val, props) {\n        setRootElementAttributes('html', { lang: val });\n        noProp(props, this.ogLocale) && setOgLocaleIfValid(val);\n    },\n    ogLocale: function ogLocale(val) {\n        setMetaContent('property=\"og:locale\"', val);\n    },\n    url: function url(val) {\n        setHeadElementAttributes('link[rel=\"canonical\"]', { href: val });\n        setMetaContent('property=\"og:url\"', val);\n        setMetaContent('name=\"twitter:url\"', val);\n    }\n};\n\nfunction headful(props, userConf) {\n    Object.assign(conf, userConf);\n    Object.keys(props).forEach(function (prop) {\n        if (!propertySetters.hasOwnProperty(prop)) {\n            throw new Error('Headful: Property \\'' + prop + '\\' is unknown.');\n        }\n        propertySetters[prop](props[prop], props);\n    });\n}\n\nheadful.props = propertySetters;\n\n/**\n * Tests whether the given `props` object contains a property with the name of `propNameOrFunction`.\n */\nfunction noProp(props, propNameOrFunction) {\n    if (!props) {\n        throw new Error('Headful: You must pass all declared props when you use headful.props.x() calls.');\n    }\n    var propName = typeof propNameOrFunction === 'function' ? propNameOrFunction.name : propNameOrFunction;\n    return !props.hasOwnProperty(propName);\n}\n\nfunction setMetaContent(attr, val) {\n    setHeadElementAttributes('meta[' + attr + ']', { content: val });\n}\n\nfunction setRootElementAttributes(selector, attributes) {\n    setElementAttributes(getElement(document, selector), attributes);\n}\n\nfunction setHeadElementAttributes(selector, attributes) {\n    setElementAttributes(getElement(document.head, selector), attributes);\n}\n\nfunction setElementAttributes(element, attributes) {\n    if (element) {\n        Object.keys(attributes).forEach(function (attrName) {\n            if (isRemoveValue(attributes[attrName])) {\n                element.removeAttribute(attrName);\n            } else {\n                element.setAttribute(attrName, attributes[attrName]);\n            }\n        });\n    }\n}\n\nfunction getElement(parent, selector) {\n    var element = parent.querySelector(selector);\n    if (!element && conf.debug) {\n        console.error('Headful: Element \\'' + selector + '\\' was not found.');\n    }\n    return element;\n}\n\nfunction setOgLocaleIfValid(locale) {\n    if (isRemoveValue(locale)) {\n        propertySetters.ogLocale(locale);\n    } else if (locale.match(/^[a-z]{2}-[a-z]{2}$/i)) {\n        var _locale$split = locale.split('-'),\n            _locale$split2 = _slicedToArray(_locale$split, 2),\n            language = _locale$split2[0],\n            region = _locale$split2[1];\n\n        var ogLocale = language + '_' + region.toUpperCase();\n        propertySetters.ogLocale(ogLocale);\n    }\n}\n\nfunction isRemoveValue(val) {\n    return val === undefined || val === null;\n}","import { visit } from \"./visitor.mjs\";\nimport { printBlockString } from \"./blockString.mjs\";\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\nexport function print(ast) {\n  return visit(ast, {\n    leave: printDocASTReducer\n  });\n}\nvar MAX_LINE_LENGTH = 80; // TODO: provide better type coverage in future\n\nvar printDocASTReducer = {\n  Name: function Name(node) {\n    return node.value;\n  },\n  Variable: function Variable(node) {\n    return '$' + node.name;\n  },\n  // Document\n  Document: function Document(node) {\n    return join(node.definitions, '\\n\\n') + '\\n';\n  },\n  OperationDefinition: function OperationDefinition(node) {\n    var op = node.operation;\n    var name = node.name;\n    var varDefs = wrap('(', join(node.variableDefinitions, ', '), ')');\n    var directives = join(node.directives, ' ');\n    var selectionSet = node.selectionSet; // Anonymous queries with no directives or variable definitions can use\n    // the query short form.\n\n    return !name && !directives && !varDefs && op === 'query' ? selectionSet : join([op, join([name, varDefs]), directives, selectionSet], ' ');\n  },\n  VariableDefinition: function VariableDefinition(_ref) {\n    var variable = _ref.variable,\n        type = _ref.type,\n        defaultValue = _ref.defaultValue,\n        directives = _ref.directives;\n    return variable + ': ' + type + wrap(' = ', defaultValue) + wrap(' ', join(directives, ' '));\n  },\n  SelectionSet: function SelectionSet(_ref2) {\n    var selections = _ref2.selections;\n    return block(selections);\n  },\n  Field: function Field(_ref3) {\n    var alias = _ref3.alias,\n        name = _ref3.name,\n        args = _ref3.arguments,\n        directives = _ref3.directives,\n        selectionSet = _ref3.selectionSet;\n    var prefix = wrap('', alias, ': ') + name;\n    var argsLine = prefix + wrap('(', join(args, ', '), ')');\n\n    if (argsLine.length > MAX_LINE_LENGTH) {\n      argsLine = prefix + wrap('(\\n', indent(join(args, '\\n')), '\\n)');\n    }\n\n    return join([argsLine, join(directives, ' '), selectionSet], ' ');\n  },\n  Argument: function Argument(_ref4) {\n    var name = _ref4.name,\n        value = _ref4.value;\n    return name + ': ' + value;\n  },\n  // Fragments\n  FragmentSpread: function FragmentSpread(_ref5) {\n    var name = _ref5.name,\n        directives = _ref5.directives;\n    return '...' + name + wrap(' ', join(directives, ' '));\n  },\n  InlineFragment: function InlineFragment(_ref6) {\n    var typeCondition = _ref6.typeCondition,\n        directives = _ref6.directives,\n        selectionSet = _ref6.selectionSet;\n    return join(['...', wrap('on ', typeCondition), join(directives, ' '), selectionSet], ' ');\n  },\n  FragmentDefinition: function FragmentDefinition(_ref7) {\n    var name = _ref7.name,\n        typeCondition = _ref7.typeCondition,\n        variableDefinitions = _ref7.variableDefinitions,\n        directives = _ref7.directives,\n        selectionSet = _ref7.selectionSet;\n    return (// Note: fragment variable definitions are experimental and may be changed\n      // or removed in the future.\n      \"fragment \".concat(name).concat(wrap('(', join(variableDefinitions, ', '), ')'), \" \") + \"on \".concat(typeCondition, \" \").concat(wrap('', join(directives, ' '), ' ')) + selectionSet\n    );\n  },\n  // Value\n  IntValue: function IntValue(_ref8) {\n    var value = _ref8.value;\n    return value;\n  },\n  FloatValue: function FloatValue(_ref9) {\n    var value = _ref9.value;\n    return value;\n  },\n  StringValue: function StringValue(_ref10, key) {\n    var value = _ref10.value,\n        isBlockString = _ref10.block;\n    return isBlockString ? printBlockString(value, key === 'description' ? '' : '  ') : JSON.stringify(value);\n  },\n  BooleanValue: function BooleanValue(_ref11) {\n    var value = _ref11.value;\n    return value ? 'true' : 'false';\n  },\n  NullValue: function NullValue() {\n    return 'null';\n  },\n  EnumValue: function EnumValue(_ref12) {\n    var value = _ref12.value;\n    return value;\n  },\n  ListValue: function ListValue(_ref13) {\n    var values = _ref13.values;\n    return '[' + join(values, ', ') + ']';\n  },\n  ObjectValue: function ObjectValue(_ref14) {\n    var fields = _ref14.fields;\n    return '{' + join(fields, ', ') + '}';\n  },\n  ObjectField: function ObjectField(_ref15) {\n    var name = _ref15.name,\n        value = _ref15.value;\n    return name + ': ' + value;\n  },\n  // Directive\n  Directive: function Directive(_ref16) {\n    var name = _ref16.name,\n        args = _ref16.arguments;\n    return '@' + name + wrap('(', join(args, ', '), ')');\n  },\n  // Type\n  NamedType: function NamedType(_ref17) {\n    var name = _ref17.name;\n    return name;\n  },\n  ListType: function ListType(_ref18) {\n    var type = _ref18.type;\n    return '[' + type + ']';\n  },\n  NonNullType: function NonNullType(_ref19) {\n    var type = _ref19.type;\n    return type + '!';\n  },\n  // Type System Definitions\n  SchemaDefinition: addDescription(function (_ref20) {\n    var directives = _ref20.directives,\n        operationTypes = _ref20.operationTypes;\n    return join(['schema', join(directives, ' '), block(operationTypes)], ' ');\n  }),\n  OperationTypeDefinition: function OperationTypeDefinition(_ref21) {\n    var operation = _ref21.operation,\n        type = _ref21.type;\n    return operation + ': ' + type;\n  },\n  ScalarTypeDefinition: addDescription(function (_ref22) {\n    var name = _ref22.name,\n        directives = _ref22.directives;\n    return join(['scalar', name, join(directives, ' ')], ' ');\n  }),\n  ObjectTypeDefinition: addDescription(function (_ref23) {\n    var name = _ref23.name,\n        interfaces = _ref23.interfaces,\n        directives = _ref23.directives,\n        fields = _ref23.fields;\n    return join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  FieldDefinition: addDescription(function (_ref24) {\n    var name = _ref24.name,\n        args = _ref24.arguments,\n        type = _ref24.type,\n        directives = _ref24.directives;\n    return name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + ': ' + type + wrap(' ', join(directives, ' '));\n  }),\n  InputValueDefinition: addDescription(function (_ref25) {\n    var name = _ref25.name,\n        type = _ref25.type,\n        defaultValue = _ref25.defaultValue,\n        directives = _ref25.directives;\n    return join([name + ': ' + type, wrap('= ', defaultValue), join(directives, ' ')], ' ');\n  }),\n  InterfaceTypeDefinition: addDescription(function (_ref26) {\n    var name = _ref26.name,\n        interfaces = _ref26.interfaces,\n        directives = _ref26.directives,\n        fields = _ref26.fields;\n    return join(['interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  }),\n  UnionTypeDefinition: addDescription(function (_ref27) {\n    var name = _ref27.name,\n        directives = _ref27.directives,\n        types = _ref27.types;\n    return join(['union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  }),\n  EnumTypeDefinition: addDescription(function (_ref28) {\n    var name = _ref28.name,\n        directives = _ref28.directives,\n        values = _ref28.values;\n    return join(['enum', name, join(directives, ' '), block(values)], ' ');\n  }),\n  EnumValueDefinition: addDescription(function (_ref29) {\n    var name = _ref29.name,\n        directives = _ref29.directives;\n    return join([name, join(directives, ' ')], ' ');\n  }),\n  InputObjectTypeDefinition: addDescription(function (_ref30) {\n    var name = _ref30.name,\n        directives = _ref30.directives,\n        fields = _ref30.fields;\n    return join(['input', name, join(directives, ' '), block(fields)], ' ');\n  }),\n  DirectiveDefinition: addDescription(function (_ref31) {\n    var name = _ref31.name,\n        args = _ref31.arguments,\n        repeatable = _ref31.repeatable,\n        locations = _ref31.locations;\n    return 'directive @' + name + (hasMultilineItems(args) ? wrap('(\\n', indent(join(args, '\\n')), '\\n)') : wrap('(', join(args, ', '), ')')) + (repeatable ? ' repeatable' : '') + ' on ' + join(locations, ' | ');\n  }),\n  SchemaExtension: function SchemaExtension(_ref32) {\n    var directives = _ref32.directives,\n        operationTypes = _ref32.operationTypes;\n    return join(['extend schema', join(directives, ' '), block(operationTypes)], ' ');\n  },\n  ScalarTypeExtension: function ScalarTypeExtension(_ref33) {\n    var name = _ref33.name,\n        directives = _ref33.directives;\n    return join(['extend scalar', name, join(directives, ' ')], ' ');\n  },\n  ObjectTypeExtension: function ObjectTypeExtension(_ref34) {\n    var name = _ref34.name,\n        interfaces = _ref34.interfaces,\n        directives = _ref34.directives,\n        fields = _ref34.fields;\n    return join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {\n    var name = _ref35.name,\n        interfaces = _ref35.interfaces,\n        directives = _ref35.directives,\n        fields = _ref35.fields;\n    return join(['extend interface', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ');\n  },\n  UnionTypeExtension: function UnionTypeExtension(_ref36) {\n    var name = _ref36.name,\n        directives = _ref36.directives,\n        types = _ref36.types;\n    return join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? '= ' + join(types, ' | ') : ''], ' ');\n  },\n  EnumTypeExtension: function EnumTypeExtension(_ref37) {\n    var name = _ref37.name,\n        directives = _ref37.directives,\n        values = _ref37.values;\n    return join(['extend enum', name, join(directives, ' '), block(values)], ' ');\n  },\n  InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {\n    var name = _ref38.name,\n        directives = _ref38.directives,\n        fields = _ref38.fields;\n    return join(['extend input', name, join(directives, ' '), block(fields)], ' ');\n  }\n};\n\nfunction addDescription(cb) {\n  return function (node) {\n    return join([node.description, cb(node)], '\\n');\n  };\n}\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray) {\n  var _maybeArray$filter$jo;\n\n  var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function (x) {\n    return x;\n  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : '';\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return wrap('{\\n', indent(join(array, '\\n')), '\\n}');\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise print an empty string.\n */\n\n\nfunction wrap(start, maybeString) {\n  var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  return maybeString != null && maybeString !== '' ? start + maybeString + end : '';\n}\n\nfunction indent(str) {\n  return wrap('  ', str.replace(/\\n/g, '\\n  '));\n}\n\nfunction isMultiline(str) {\n  return str.indexOf('\\n') !== -1;\n}\n\nfunction hasMultilineItems(maybeArray) {\n  return maybeArray != null && maybeArray.some(isMultiline);\n}\n","import defineInspect from \"../jsutils/defineInspect.mjs\";\n\n/**\n * Contains a range of UTF-8 character offsets and token references that\n * identify the region of the source from which the AST derived.\n */\nexport var Location = /*#__PURE__*/function () {\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The Token at which this Node begins.\n   */\n\n  /**\n   * The Token at which this Node ends.\n   */\n\n  /**\n   * The Source document the AST represents.\n   */\n  function Location(startToken, endToken, source) {\n    this.start = startToken.start;\n    this.end = endToken.end;\n    this.startToken = startToken;\n    this.endToken = endToken;\n    this.source = source;\n  }\n\n  var _proto = Location.prototype;\n\n  _proto.toJSON = function toJSON() {\n    return {\n      start: this.start,\n      end: this.end\n    };\n  };\n\n  return Location;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(Location);\n/**\n * Represents a range of characters represented by a lexical token\n * within a Source.\n */\n\nexport var Token = /*#__PURE__*/function () {\n  /**\n   * The kind of Token.\n   */\n\n  /**\n   * The character offset at which this Node begins.\n   */\n\n  /**\n   * The character offset at which this Node ends.\n   */\n\n  /**\n   * The 1-indexed line number on which this Token appears.\n   */\n\n  /**\n   * The 1-indexed column number at which this Token begins.\n   */\n\n  /**\n   * For non-punctuation tokens, represents the interpreted value of the token.\n   */\n\n  /**\n   * Tokens exist as nodes in a double-linked-list amongst all tokens\n   * including ignored tokens. <SOF> is always the first node and <EOF>\n   * the last.\n   */\n  function Token(kind, start, end, line, column, prev, value) {\n    this.kind = kind;\n    this.start = start;\n    this.end = end;\n    this.line = line;\n    this.column = column;\n    this.value = value;\n    this.prev = prev;\n    this.next = null;\n  }\n\n  var _proto2 = Token.prototype;\n\n  _proto2.toJSON = function toJSON() {\n    return {\n      kind: this.kind,\n      value: this.value,\n      line: this.line,\n      column: this.column\n    };\n  };\n\n  return Token;\n}(); // Print a simplified form when appearing in `inspect` and `util.inspect`.\n\ndefineInspect(Token);\n/**\n * @internal\n */\n\nexport function isNode(maybeNode) {\n  return maybeNode != null && typeof maybeNode.kind === 'string';\n}\n/**\n * The list of all possible AST node types.\n */\n","/**\n * Represents a location in a Source.\n */\n\n/**\n * Takes a Source and a UTF-8 character offset, and returns the corresponding\n * line and column as a SourceLocation.\n */\nexport function getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n","import { getLocation } from \"./location.mjs\";\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n/**\n * Render a helpful description of the location in the GraphQL Source document.\n */\n\nexport function printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineOffset = source.locationOffset.line - 1;\n  var lineNum = sourceLocation.line + lineOffset;\n  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;\n  var columnNum = sourceLocation.column + columnOffset;\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex]; // Special case for minified documents\n\n  if (locationLine.length > 120) {\n    var subLineIndex = Math.floor(columnNum / 80);\n    var subLineColumnNum = columnNum % 80;\n    var subLines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      subLines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function (subLine) {\n      return ['', subLine];\n    }), [[' ', whitespace(subLineColumnNum - 1) + '^'], ['', subLines[subLineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([// Lines specified like this: [\"prefix\", \"string\"],\n  [\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], ['', whitespace(columnNum - 1) + '^'], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    var _ = _ref[0],\n        line = _ref[1];\n    return line !== undefined;\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    var prefix = _ref2[0];\n    return prefix.length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var prefix = _ref3[0],\n        line = _ref3[1];\n    return leftPad(padLen, prefix) + (line ? ' | ' + line : ' |');\n  }).join('\\n');\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(' ');\n}\n\nfunction leftPad(len, str) {\n  return whitespace(len - str.length) + str;\n}\n","// In ES2015 (or a polyfilled) environment, this will be Symbol.iterator\n// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\nexport var SYMBOL_ITERATOR = typeof Symbol === 'function' && Symbol.iterator != null ? Symbol.iterator : '@@iterator'; // In ES2017 (or a polyfilled) environment, this will be Symbol.asyncIterator\n// istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\nexport var SYMBOL_ASYNC_ITERATOR = typeof Symbol === 'function' && Symbol.asyncIterator != null ? Symbol.asyncIterator : '@@asyncIterator'; // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')\n\nexport var SYMBOL_TO_STRING_TAG = typeof Symbol === 'function' && Symbol.toStringTag != null ? Symbol.toStringTag : '@@toStringTag';\n"],"sourceRoot":""}